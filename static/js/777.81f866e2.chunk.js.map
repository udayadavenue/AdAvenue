{"version":3,"file":"static/js/777.81f866e2.chunk.js","mappings":"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","sources":["../node_modules/src/controls/OrbitControls.ts","../node_modules/@react-three/drei/core/OrbitControls.js","../node_modules/src/loaders/DRACOLoader.js","../node_modules/src/libs/MeshoptDecoder.ts","../node_modules/src/utils/BufferGeometryUtils.ts","../node_modules/src/_polyfill/constants.ts","../node_modules/src/loaders/GLTFLoader.js","../node_modules/@react-three/drei/core/useGLTF.js"],"sourcesContent":["import {\n  EventDispatcher,\n  Matrix4,\n  MOUSE,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Ray,\n  Plane,\n} from 'three'\n\nconst _ray = new Ray()\nconst _plane = new Plane()\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180))\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst moduloWrapAround = (offset: number, capacity: number) => ((offset % capacity) + capacity) % capacity\n\nclass OrbitControls extends EventDispatcher {\n  object: PerspectiveCamera | OrthographicCamera\n  domElement: HTMLElement | undefined\n  // Set to false to disable this control\n  enabled = true\n  // \"target\" sets the location of focus, where the object orbits around\n  target = new Vector3()\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  minDistance = 0\n  maxDistance = Infinity\n  // How far you can zoom in and out ( OrthographicCamera only )\n  minZoom = 0\n  maxZoom = Infinity\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  minPolarAngle = 0 // radians\n  maxPolarAngle = Math.PI // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  minAzimuthAngle = -Infinity // radians\n  maxAzimuthAngle = Infinity // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  enableDamping = false\n  dampingFactor = 0.05\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  enableZoom = true\n  zoomSpeed = 1.0\n  // Set to false to disable rotating\n  enableRotate = true\n  rotateSpeed = 1.0\n  // Set to false to disable panning\n  enablePan = true\n  panSpeed = 1.0\n  screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up\n  keyPanSpeed = 7.0 // pixels moved per arrow key push\n  zoomToCursor = false\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  autoRotate = false\n  autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60\n  reverseOrbit = false // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n  reverseHorizontalOrbit = false // true if you want to reverse the horizontal orbit direction\n  reverseVerticalOrbit = false // true if you want to reverse the vertical orbit direction\n  // The four arrow keys\n  keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }\n  // Mouse buttons\n  mouseButtons: Partial<{\n    LEFT: MOUSE\n    MIDDLE: MOUSE\n    RIGHT: MOUSE\n  }> = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  }\n  // Touch fingers\n  touches: Partial<{\n    ONE: TOUCH\n    TWO: TOUCH\n  }> = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }\n  target0: Vector3\n  position0: Vector3\n  zoom0: number\n  // the target DOM element for key events\n  _domElementKeyEvents: any = null\n\n  getPolarAngle: () => number\n  getAzimuthalAngle: () => number\n  setPolarAngle: (x: number) => void\n  setAzimuthalAngle: (x: number) => void\n  getDistance: () => number\n\n  listenToKeyEvents: (domElement: HTMLElement) => void\n  stopListenToKeyEvents: () => void\n  saveState: () => void\n  reset: () => void\n  update: () => void\n  connect: (domElement: HTMLElement) => void\n  dispose: () => void\n\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    // for reset\n    this.target0 = this.target.clone()\n    this.position0 = this.object.position.clone()\n    this.zoom0 = this.object.zoom\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = (): number => spherical.phi\n\n    this.getAzimuthalAngle = (): number => spherical.theta\n\n    this.setPolarAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let phi = moduloWrapAround(value, 2 * Math.PI)\n      let currentPhi = spherical.phi\n\n      // convert to the equivalent shortest angle\n      if (currentPhi < 0) currentPhi += 2 * Math.PI\n      if (phi < 0) phi += 2 * Math.PI\n      let phiDist = Math.abs(phi - currentPhi)\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI\n        } else {\n          currentPhi += 2 * Math.PI\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi\n      scope.update()\n    }\n\n    this.setAzimuthalAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let theta = moduloWrapAround(value, 2 * Math.PI)\n      let currentTheta = spherical.theta\n\n      // convert to the equivalent shortest angle\n      if (currentTheta < 0) currentTheta += 2 * Math.PI\n      if (theta < 0) theta += 2 * Math.PI\n      let thetaDist = Math.abs(theta - currentTheta)\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI\n        } else {\n          currentTheta += 2 * Math.PI\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta\n      scope.update()\n    }\n\n    this.getDistance = (): number => scope.object.position.distanceTo(scope.target)\n\n    this.listenToKeyEvents = (domElement: HTMLElement): void => {\n      domElement.addEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = domElement\n    }\n\n    this.stopListenToKeyEvents = (): void => {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = null\n    }\n\n    this.saveState = (): void => {\n      scope.target0.copy(scope.target)\n      scope.position0.copy(scope.object.position)\n      scope.zoom0 = scope.object.zoom\n    }\n\n    this.reset = (): void => {\n      scope.target.copy(scope.target0)\n      scope.object.position.copy(scope.position0)\n      scope.object.zoom = scope.zoom0\n      scope.object.updateProjectionMatrix()\n\n      // @ts-ignore\n      scope.dispatchEvent(changeEvent)\n\n      scope.update()\n\n      state = STATE.NONE\n    }\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = ((): (() => void) => {\n      const offset = new Vector3()\n      const up = new Vector3(0, 1, 0)\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(object.up, up)\n      const quatInverse = quat.clone().invert()\n\n      const lastPosition = new Vector3()\n      const lastQuaternion = new Quaternion()\n\n      const twoPI = 2 * Math.PI\n\n      return function update(): boolean {\n        const position = scope.object.position\n\n        // update new up direction\n        quat.setFromUnitVectors(object.up, up)\n        quatInverse.copy(quat).invert()\n\n        offset.copy(position).sub(scope.target)\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat)\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset)\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle())\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor\n        } else {\n          spherical.theta += sphericalDelta.theta\n          spherical.phi += sphericalDelta.phi\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle\n        let max = scope.maxAzimuthAngle\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI\n          else if (min > Math.PI) min -= twoPI\n\n          if (max < -Math.PI) max += twoPI\n          else if (max > Math.PI) max -= twoPI\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta))\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi))\n        spherical.makeSafe()\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor)\n        } else {\n          scope.target.add(panOffset)\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if (\n          (scope.zoomToCursor && performCursorZoom) ||\n          (scope.object as THREE.OrthographicCamera).isOrthographicCamera\n        ) {\n          spherical.radius = clampDistance(spherical.radius)\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale)\n        }\n\n        offset.setFromSpherical(spherical)\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse)\n\n        position.copy(scope.target).add(offset)\n\n        if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix()\n        scope.object.lookAt(scope.target)\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor\n          sphericalDelta.phi *= 1 - scope.dampingFactor\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor)\n        } else {\n          sphericalDelta.set(0, 0, 0)\n\n          panOffset.set(0, 0, 0)\n        }\n\n        // adjust camera position\n        let zoomChanged = false\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length()\n            newRadius = clampDistance(prevRadius * scale)\n\n            const radiusDelta = prevRadius - newRadius\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta)\n            scope.object.updateMatrixWorld()\n          } else if ((scope.object as THREE.OrthographicCamera).isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0)\n            mouseBefore.unproject(scope.object)\n\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n            zoomChanged = true\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0)\n            mouseAfter.unproject(scope.object)\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore)\n            scope.object.updateMatrixWorld()\n\n            newRadius = offset.length()\n          } else {\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.')\n            scope.zoomToCursor = false\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position)\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position)\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix)\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target)\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target)\n                _ray.intersectPlane(_plane, scope.target)\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1\n\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n          }\n        }\n\n        scale = 1\n        performCursorZoom = false\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          // @ts-ignore\n          scope.dispatchEvent(changeEvent)\n\n          lastPosition.copy(scope.object.position)\n          lastQuaternion.copy(scope.object.quaternion)\n          zoomChanged = false\n\n          return true\n        }\n\n        return false\n      }\n    })()\n\n    // https://github.com/mrdoob/three.js/issues/20575\n    this.connect = (domElement: HTMLElement): void => {\n      if ((domElement as any) === document) {\n        console.error(\n          'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.',\n        )\n      }\n      scope.domElement = domElement\n      // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n      scope.domElement.style.touchAction = 'none'\n      scope.domElement.addEventListener('contextmenu', onContextMenu)\n      scope.domElement.addEventListener('pointerdown', onPointerDown)\n      scope.domElement.addEventListener('pointercancel', onPointerCancel)\n      scope.domElement.addEventListener('wheel', onMouseWheel)\n    }\n\n    this.dispose = (): void => {\n      scope.domElement?.removeEventListener('contextmenu', onContextMenu)\n      scope.domElement?.removeEventListener('pointerdown', onPointerDown)\n      scope.domElement?.removeEventListener('pointercancel', onPointerCancel)\n      scope.domElement?.removeEventListener('wheel', onMouseWheel)\n      scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n      scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      }\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    //\n    // internals\n    //\n\n    const scope = this\n\n    const changeEvent = { type: 'change' }\n    const startEvent = { type: 'start' }\n    const endEvent = { type: 'end' }\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    }\n\n    let state = STATE.NONE\n\n    const EPS = 0.000001\n\n    // current position in spherical coordinates\n    const spherical = new Spherical()\n    const sphericalDelta = new Spherical()\n\n    let scale = 1\n    const panOffset = new Vector3()\n\n    const rotateStart = new Vector2()\n    const rotateEnd = new Vector2()\n    const rotateDelta = new Vector2()\n\n    const panStart = new Vector2()\n    const panEnd = new Vector2()\n    const panDelta = new Vector2()\n\n    const dollyStart = new Vector2()\n    const dollyEnd = new Vector2()\n    const dollyDelta = new Vector2()\n\n    const dollyDirection = new Vector3()\n    const mouse = new Vector2()\n    let performCursorZoom = false\n\n    const pointers: PointerEvent[] = []\n    const pointerPositions: { [key: string]: Vector2 } = {}\n\n    function getAutoRotationAngle(): number {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed\n    }\n\n    function getZoomScale(): number {\n      return Math.pow(0.95, scope.zoomSpeed)\n    }\n\n    function rotateLeft(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle\n      } else {\n        sphericalDelta.theta -= angle\n      }\n    }\n\n    function rotateUp(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle\n      } else {\n        sphericalDelta.phi -= angle\n      }\n    }\n\n    const panLeft = (() => {\n      const v = new Vector3()\n\n      return function panLeft(distance: number, objectMatrix: Matrix4) {\n        v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix\n        v.multiplyScalar(-distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    const panUp = (() => {\n      const v = new Vector3()\n\n      return function panUp(distance: number, objectMatrix: Matrix4) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1)\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0)\n          v.crossVectors(scope.object.up, v)\n        }\n\n        v.multiplyScalar(distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (() => {\n      const offset = new Vector3()\n\n      return function pan(deltaX: number, deltaY: number) {\n        const element = scope.domElement\n\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position\n          offset.copy(position).sub(scope.target)\n          let targetDistance = offset.length()\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0)\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix)\n          panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix)\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix,\n          )\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix,\n          )\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')\n          scope.enablePan = false\n        }\n      }\n    })()\n\n    function dollyOut(dollyScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale /= dollyScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function dollyIn(dollyScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale *= dollyScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function updateMouseParameters(event: MouseEvent): void {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return\n      }\n\n      performCursorZoom = true\n\n      const rect = scope.domElement.getBoundingClientRect()\n      const x = event.clientX - rect.left\n      const y = event.clientY - rect.top\n      const w = rect.width\n      const h = rect.height\n\n      mouse.x = (x / w) * 2 - 1\n      mouse.y = -(y / h) * 2 + 1\n\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize()\n    }\n\n    function clampDistance(dist: number): number {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist))\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event: MouseEvent) {\n      rotateStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownDolly(event: MouseEvent) {\n      updateMouseParameters(event)\n      dollyStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownPan(event: MouseEvent) {\n      panStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseMoveRotate(event: MouseEvent) {\n      rotateEnd.set(event.clientX, event.clientY)\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n      scope.update()\n    }\n\n    function handleMouseMoveDolly(event: MouseEvent) {\n      dollyEnd.set(event.clientX, event.clientY)\n      dollyDelta.subVectors(dollyEnd, dollyStart)\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale())\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale())\n      }\n\n      dollyStart.copy(dollyEnd)\n      scope.update()\n    }\n\n    function handleMouseMovePan(event: MouseEvent) {\n      panEnd.set(event.clientX, event.clientY)\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n      scope.update()\n    }\n\n    function handleMouseWheel(event: WheelEvent) {\n      updateMouseParameters(event)\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale())\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale())\n      }\n\n      scope.update()\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      let needsUpdate = false\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault()\n        scope.update()\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        rotateStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        panStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX\n      const dy = pointers[0].pageY - pointers[1].pageY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyStart.set(0, distance)\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enablePan) handleTouchStartPan()\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enableRotate) handleTouchStartRotate()\n    }\n\n    function handleTouchMoveRotate(event: PointerEvent) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        rotateEnd.set(x, y)\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n    }\n\n    function handleTouchMovePan(event: PointerEvent) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        panEnd.set(x, y)\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n    }\n\n    function handleTouchMoveDolly(event: PointerEvent) {\n      const position = getSecondPointerPosition(event)\n      const dx = event.pageX - position.x\n      const dy = event.pageY - position.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyEnd.set(0, distance)\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))\n      dollyOut(dollyDelta.y)\n      dollyStart.copy(dollyEnd)\n    }\n\n    function handleTouchMoveDollyPan(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enablePan) handleTouchMovePan(event)\n    }\n\n    function handleTouchMoveDollyRotate(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enableRotate) handleTouchMoveRotate(event)\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (pointers.length === 0) {\n        scope.domElement?.ownerDocument.addEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.addEventListener('pointerup', onPointerUp)\n      }\n\n      addPointer(event)\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event)\n      } else {\n        onMouseDown(event)\n      }\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event)\n      } else {\n        onMouseMove(event)\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      removePointer(event)\n\n      if (pointers.length === 0) {\n        scope.domElement?.releasePointerCapture(event.pointerId)\n\n        scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      }\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n\n      state = STATE.NONE\n    }\n\n    function onPointerCancel(event: PointerEvent) {\n      removePointer(event)\n    }\n\n    function onMouseDown(event: MouseEvent) {\n      let mouseAction\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT\n          break\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE\n          break\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT\n          break\n\n        default:\n          mouseAction = -1\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseDownDolly(event)\n          state = STATE.DOLLY\n          break\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          } else {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          }\n          break\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          } else {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          }\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onMouseMove(event: MouseEvent) {\n      if (scope.enabled === false) return\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return\n          handleMouseMoveRotate(event)\n          break\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseMoveDolly(event)\n          break\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return\n          handleMouseMovePan(event)\n          break\n      }\n    }\n\n    function onMouseWheel(event: WheelEvent) {\n      if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) {\n        return\n      }\n\n      event.preventDefault()\n\n      // @ts-ignore\n      scope.dispatchEvent(startEvent)\n\n      handleMouseWheel(event)\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (scope.enabled === false || scope.enablePan === false) return\n      handleKeyDown(event)\n    }\n\n    function onTouchStart(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return\n              handleTouchStartRotate()\n              state = STATE.TOUCH_ROTATE\n              break\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return\n              handleTouchStartPan()\n              state = STATE.TOUCH_PAN\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return\n              handleTouchStartDollyPan()\n              state = STATE.TOUCH_DOLLY_PAN\n              break\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return\n              handleTouchStartDollyRotate()\n              state = STATE.TOUCH_DOLLY_ROTATE\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onTouchMove(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return\n          handleTouchMoveRotate(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return\n          handleTouchMovePan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return\n          handleTouchMoveDollyPan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return\n          handleTouchMoveDollyRotate(event)\n          scope.update()\n          break\n\n        default:\n          state = STATE.NONE\n      }\n    }\n\n    function onContextMenu(event: Event) {\n      if (scope.enabled === false) return\n      event.preventDefault()\n    }\n\n    function addPointer(event: PointerEvent) {\n      pointers.push(event)\n    }\n\n    function removePointer(event: PointerEvent) {\n      delete pointerPositions[event.pointerId]\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    function trackPointer(event: PointerEvent) {\n      let position = pointerPositions[event.pointerId]\n\n      if (position === undefined) {\n        position = new Vector2()\n        pointerPositions[event.pointerId] = position\n      }\n\n      position.set(event.pageX, event.pageY)\n    }\n\n    function getSecondPointerPosition(event: PointerEvent) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]\n      return pointerPositions[pointer.pointerId]\n    }\n\n    // connect events\n    if (domElement !== undefined) this.connect(domElement)\n    // force an update at start\n    this.update()\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super(object, domElement)\n\n    this.screenSpacePanning = false // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN\n    this.mouseButtons.RIGHT = MOUSE.ROTATE\n\n    this.touches.ONE = TOUCH.PAN\n    this.touches.TWO = TOUCH.DOLLY_ROTATE\n  }\n}\n\nexport { OrbitControls, MapControls }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /* @__PURE__ */React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const setEvents = useThree(state => state.setEvents);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n","import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n","// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2020, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\ntype API = {\n  ready: Promise<void>\n  supported: boolean\n  decodeVertexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array, filter?: string) => void\n  decodeIndexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeIndexSequence: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeGltfBuffer: (\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    mode: string,\n    filter?: string,\n  ) => void\n}\n\nlet generated: API\n\nconst MeshoptDecoder = () => {\n  if (generated) return generated\n\n  // Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n  // Built from meshoptimizer 0.14\n  const wasm_base =\n    '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'\n  const wasm_simd =\n    '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'\n\n  // Uses bulk-memory and simd extensions\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11,\n  ])\n\n  // Used to unpack wasm\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167,\n  ])\n\n  if (typeof WebAssembly !== 'object') {\n    // This module requires WebAssembly to function\n    return {\n      supported: false,\n    }\n  }\n\n  let wasm = wasm_base\n\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd\n  }\n\n  let instance: any // WebAssembly.Instance\n\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance\n    instance.exports.__wasm_call_ctors()\n  })\n\n  function unpack(data: string) {\n    const result = new Uint8Array(data.length)\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i)\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62\n    }\n    let write = 0\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i]\n    }\n    return result.buffer.slice(0, write)\n  }\n\n  function decode(\n    fun: Function,\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    filter?: Function,\n  ) {\n    const sbrk = instance.exports.sbrk\n    const count4 = (count + 3) & ~3 // pad for SIMD filter\n    const tp = sbrk(count4 * size)\n    const sp = sbrk(source.length)\n    const heap = new Uint8Array(instance.exports.memory.buffer)\n    heap.set(source, sp)\n    const res = fun(tp, count, size, sp, source.length)\n    if (res === 0 && filter) {\n      filter(tp, count4, size)\n    }\n    target.set(heap.subarray(tp, tp + count * size))\n    sbrk(tp - sbrk(0))\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`)\n    }\n  }\n\n  const filters = {\n    // legacy index-based enums for glTF\n    0: '',\n    1: 'meshopt_decodeFilterOct',\n    2: 'meshopt_decodeFilterQuat',\n    3: 'meshopt_decodeFilterExp',\n    // string-based enums for glTF\n    NONE: '',\n    OCTAHEDRAL: 'meshopt_decodeFilterOct',\n    QUATERNION: 'meshopt_decodeFilterQuat',\n    EXPONENTIAL: 'meshopt_decodeFilterExp',\n  }\n\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: 'meshopt_decodeVertexBuffer',\n    1: 'meshopt_decodeIndexBuffer',\n    2: 'meshopt_decodeIndexSequence',\n    // string-based enums for glTF\n    ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n    TRIANGLES: 'meshopt_decodeIndexBuffer',\n    INDICES: 'meshopt_decodeIndexSequence',\n  }\n\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source)\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source)\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode as keyof typeof decoders]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n  }\n\n  return generated\n}\n\nexport { MeshoptDecoder }\n","import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n","import { REVISION } from 'three'\n\nexport const version = parseInt(REVISION.replace(/\\D+/g, ''))\n","import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      resourcePath = this.path\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(LoaderUtils.decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.fromArray(array)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, 3001)) // sRGBEncoding\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      materialParams.sheenColor.fromArray(extension.sheenColorFactor)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, 3001)) // sRGBEncoding\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2])\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2])\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, 3001), // sRGBEncoding\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = LoaderUtils.decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, encoding) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (encoding !== undefined) {\n        if ('colorSpace' in texture) texture.colorSpace = encoding === 3001 ? 'srgb' : 'srgb-linear'\n        else texture.encoding = encoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.fromArray(array)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, 3001)) // sRGBEncoding\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor)\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, 3001)) // sRGBEncoding\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        node.updateMatrix()\n\n        let TypedKeyframeTrack\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack\n            break\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        const targetName = node.name ? node.name : node.uuid\n\n        const interpolation =\n          sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n        const targetNames = []\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          node.traverse(function (object) {\n            if (object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid)\n            }\n          })\n        } else {\n          targetNames.push(targetName)\n        }\n\n        let outputArray = outputAccessor.array\n\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor)\n          const scaled = new Float32Array(outputArray.length)\n\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale\n          }\n\n          outputArray = scaled\n        }\n\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(\n            targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n            inputAccessor.array,\n            outputArray,\n            interpolation,\n          )\n\n          // Override interpolation with custom factory method.\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n\n              const interpolantType =\n                this instanceof QuaternionKeyframeTrack\n                  ? GLTFCubicSplineQuaternionInterpolant\n                  : GLTFCubicSplineInterpolant\n\n              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n            }\n\n            // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n          }\n\n          tracks.push(track)\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n","import { GLTFLoader, DRACOLoader, MeshoptDecoder } from 'three-stdlib';\nimport { useLoader } from '@react-three/fiber';\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof MeshoptDecoder === 'function' ? MeshoptDecoder() : MeshoptDecoder);\n    }\n  };\n}\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n  return useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n}\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\nuseGLTF.clear = input => useLoader.clear(GLTFLoader, input);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\nexport { useGLTF };\n"],"names":["_ray","Ray","_plane","Plane","TILT_LIMIT","Math","cos","PI","moduloWrapAround","offset","capacity","OrbitControls","EventDispatcher","constructor","object","domElement","__publicField","Vector3","Infinity","LEFT","UP","RIGHT","BOTTOM","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","ONE","TOUCH","TWO","DOLLY_PAN","this","target0","target","clone","position0","position","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","setPolarAngle","value","currentPhi","phiDist","abs","sphericalDelta","scope","update","setAzimuthalAngle","currentTheta","thetaDist","getDistance","distanceTo","listenToKeyEvents","domElement2","addEventListener","onKeyDown","_domElementKeyEvents","stopListenToKeyEvents","removeEventListener","saveState","copy","reset","updateProjectionMatrix","dispatchEvent","changeEvent","state","STATE","NONE","up","quat","Quaternion","setFromUnitVectors","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","autoRotate","rotateLeft","autoRotateSpeed","enableDamping","dampingFactor","min","minAzimuthAngle","max","maxAzimuthAngle","isFinite","minPolarAngle","maxPolarAngle","makeSafe","addScaledVector","panOffset","add","zoomToCursor","performCursorZoom","isOrthographicCamera","radius","clampDistance","scale","setFromSpherical","matrixAutoUpdate","updateMatrix","lookAt","multiplyScalar","set","zoomChanged","newRadius","PerspectiveCamera","isPerspectiveCamera","prevRadius","length","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","x","y","unproject","minZoom","maxZoom","mouseAfter","console","warn","screenSpacePanning","transformDirection","matrix","origin","direction","dot","setFromNormalAndCoplanarPoint","intersectPlane","OrthographicCamera","distanceToSquared","EPS","quaternion","connect","document","error","style","touchAction","onContextMenu","onPointerDown","onPointerCancel","onMouseWheel","dispose","_a","_b","_c","_d","_e","ownerDocument","onPointerMove","_f","onPointerUp","type","startEvent","endEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","pow","zoomSpeed","angle","reverseOrbit","reverseHorizontalOrbit","rotateUp","reverseVerticalOrbit","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","targetDistance","tan","fov","clientHeight","right","left","clientWidth","top","bottom","enablePan","dollyOut","dollyScale","enableZoom","dollyIn","updateMouseParameters","event","rect","getBoundingClientRect","clientX","clientY","w","width","h","height","normalize","dist","minDistance","maxDistance","handleMouseDownRotate","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","rotateSpeed","handleTouchMovePan","panSpeed","handleTouchMoveDolly","enabled","push","addPointer","pointerType","trackPointer","touches","enableRotate","DOLLY_ROTATE","onTouchStart","mouseAction","button","mouseButtons","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","onTouchMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","removePointer","releasePointerCapture","pointerId","preventDefault","handleMouseWheel","needsUpdate","code","keys","keyPanSpeed","handleKeyDown","i","splice","pointer","React","_ref","ref","makeDefault","camera","regress","keyEvents","onChange","onStart","onEnd","restProps","_objectWithoutProperties","_excluded","invalidate","useThree","defaultCamera","gl","events","setEvents","get","performance","explCamera","explDomElement","connected","controls","OrbitControls$1","useFrame","callback","e","onStartCb","onEndCb","old","_extends","_taskCache","WeakMap","DRACOLoader","Loader","manager","super","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","attribute","BYTES_PER_ELEMENT","name","taskKey","JSON","stringify","has","cachedTask","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","geometryData","BufferGeometry","index","setIndex","BufferAttribute","array","attributes","itemSize","setAttribute","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","worker2","Worker","_taskCosts","_taskLoad","onmessage","data","sort","a","b","debug","log","map","terminate","decodeAttribute","draco","decoder","dracoGeometry","attributeName","attributeType","numComponents","num_components","numValues","num_points","dataType","Float32Array","DT_FLOAT32","Int8Array","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","Uint32Array","DT_UINT32","getDracoDataType","ptr","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","slice","_free","onModuleLoaded","DracoDecoderModule","module","Decoder","decoderBuffer","DecoderBuffer","Init","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","error_msg","self","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numFaces","num_faces","numIndices","GetTrianglesUInt32Array","decodeIndex","destroy","buffers","attr","generated","MeshoptDecoder","detector","wasmpack","supported","instance","wasm","validate","instantiate","result","ch","charCodeAt","write","unpack","exports","__wasm_call_ctors","decode","fun","count","size","source","filter","sbrk","count4","tp","sp","heap","memory","res","subarray","concat","filters","OCTAHEDRAL","QUATERNION","EXPONENTIAL","decoders","ATTRIBUTES","TRIANGLES","INDICES","ready","decodeVertexBuffer","meshopt_decodeVertexBuffer","decodeIndexBuffer","meshopt_decodeIndexBuffer","decodeIndexSequence","meshopt_decodeIndexSequence","decodeGltfBuffer","mode","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","getIndex","indices","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","clearGroups","version","parseInt","REVISION","replace","GLTFLoader","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","resourcePath","LoaderUtils","extractUrlBase","itemStart","_onError","itemError","itemEnd","parse","gltf","setDRACOLoader","setDDSLoader","setKTX2Loader","setMeshoptDecoder","unregister","json","extensions","plugins","ArrayBuffer","decodeText","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","GLTFParser","crossOrigin","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","GLTFRegistry","objects","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDef","lights","lightNode","Color","fromArray","range","DirectionalLight","PointLight","SpotLight","spot","innerConeAngle","outerConeAngle","penumbra","decay","assignExtrasToUserData","intensity","createUniqueName","getDependency","createNodeAttachment","self2","_getNodeRef","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","baseColorTexture","assignTexture","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","clearcoatNormalScale","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","loadTexture","textureIndex","textureDef","textures","options","loadTextureImage","isSupported","images","textureLoader","uri","handler","getHandler","detectSupport","image","Image","src","onload","onerror","loadBufferView","bufferView","bufferViews","extensionDef","byteOffset","stride","byteStride","decodeGltfBufferAsync","res2","createNodeMesh","mesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","accessor","results","nodeObject","pop","isGroup","children","instancedMeshes","m","Matrix4","p","q","s","instancedMesh","InstancedMesh","material","TRANSLATION","fromBufferAttribute","ROTATION","SCALE","setMatrixAt","compose","Object3D","prototype","call","assignFinalMaterial","clear","BINARY_EXTENSION_CHUNK_TYPES","headerView","DataView","header","magic","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","extendTexture","texture","transform","texCoord","channel","rotation","repeat","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","values","valueSize","interpolate_","i1","t0","t","t1","stride2","stride3","td","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","_q","GLTFCubicSplineQuaternionInterpolant","toArray","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","_objectSpread","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","createDefaultMaterial","MeshStandardMaterial","emissive","metalness","roughness","transparent","depthTest","side","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","Object","assign","updateMorphTargets","il","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","targets","attributesKey","getNormalizedComponentScale","_identityMatrix","arguments","undefined","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","userAgent","test","match","createImageBitmap","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","updateMappings","original","mappings","child","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","resolveURL","bufferViewDef","accessorIndex","sparse","TypedArray","pendingBufferViews","elementBytes","itemBytes","bufferAttribute","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","loadImageSource","flipY","startsWith","samplers","magFilter","minFilter","wrapS","wrapT","webkitURL","sourceURI","isObjectURL","blob","mimeType","sourceURI2","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","search","mapName","mapDef","encoding","gltfReference","colorSpace","useDerivativeTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","normalScale","materialType","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","DoubleSide","alphaMode","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","meshIndex","geometries","SkinnedMesh","normalizeSkinWeights","LineSegments","Line","LineLoop","Points","morphAttributes","group","Group","cameraIndex","cameraDef","params","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","node","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","outputArray","scaled","j","jl","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","o","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","bind","nodeName","meshPromise","forEach","Bone","applyMatrix4","sceneIndex","sceneDef","nodeIds","reducedAssociations","node2","reduceAssociations","assignAttributeAccessor","gltfAttributeName","accessor2","box","Box3","boxScale","maxDisplacement","vector","expandByVector","boundingBox","sphere","Sphere","getCenter","center","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","morphPositions","morphNormals","morphColors","morphTargetsRelative","addMorphTargets","useDraco","useMeshopt","extendLoader","useGLTF","useMeshOpt","useLoader"],"ignoreList":[],"sourceRoot":""}